Extremely lightweight adapter between Rails and Solr.

SimpleSolr uses the REST interface that Solr offers and makes a great number
of assumptions. This has resulted in a very fast, very lightweight library
almost anyone can use straight away. It does mean you will be working with
query strings and hashes directly, instead of with Ruby objects.

* only a few dozen lines of code
* extremely simple DSL
* only depends on httparty
* can handle all common use cases
* has support for master/slave configurations
* does not come with a bundled Solr
* does not send a bunch of magic fields

And my personal favorite:

* <b>does nothing for unconfigured environments</b>

If you have no +development+ section in the config file (see below) then
nothing will happen at all. Your models will not be indexed, but you are
freed from having to run a local Solr instance as well.

This gem is not really suitable for use outside Rails, as it requires both
ActiveRecord and ActiveSupport.

I owe a great deal to @outoftime's Sunspot[https://github.com/outoftime/sunspot] library. If you need a fully-packed
solution that handles every Solr case you might have, use that instead.


== Installation

Rails 2, in config/environment.rb:

  config.gem 'simple_solr'
  
Rails 3, in Gemfile:

  gem 'simple_solr'
  

== Configuration

Create a file called <tt>config/simple_solr.yml</tt>.

  production:
    solr:
      hostname: "slave.local"
      port: 8000
      path: "/solr"
    master_solr:
      hostname: "master.local"
      port: 8000
      path: "/solr"

If you have just one Solr server, leave out the master_solr section.

=== Your models

Then in your models include the following:

  class Document < ActiveRecord::Base
    simple_solr do
      field :title
    end
  end

Only the fields listed in the +simple_solr+ block will be sent to Solr,
with the addition of the +id+ field which is always included. The type of
the field is not appended; the XML sent to Solr is as bare as possible.

This also means no type casting is performed on dates/times. If you need
anything like that, use a lambda to manipulate the field to your liking.

Full example:

  class FullDocument < ActiveRecord::Base
    simple_solr do
      field :id,            lambda { |record| "full-document-#{record.id}" }
      field :title
      field :date_creation, :created_at
      field :shared,        false
      field :published,     "Megacorp LLC"
      field :body
    end
  end
  
As you can see you have a couple options with regards to the fields:

1. Do nothing - in which case the corresponding attribute is used
2. A symbol - uses the instance method with that name as the value
3. Static value such as a string or boolean - which is used verbatim
4. A lambda - for your every customization need.

Use the latter form if you want to add a dynamic field to Solr. The model
instance is passed as a parameter, so you can use every method inside
the block, or run a calculation, or whatever.

== Searching

Use the +simple_search+ class method on your model:

  Document.simple_search 'apple'
  
This will make a trip to Solr and return the results as a hash. That's right.
The results are not correlated with your models. In fact, no processing is
done at all. Simple, right? If you need to fetch model instances based on the
results, that is up to you.

You can add parameters, for example if you want to limit results using +fq+:

  Document.simple_search 'apple', :fq => "category:fruit"
  
See the "Solr documentation"[http://wiki.apache.org/solr/CommonQueryParameters] for a list
of common query parameters. Just remember that the +q+ parameter will be set for you.

The response from Solr will look something like this:

  <?xml version="1.0" encoding="UTF-8"?>
  <response>
    <lst name="responseHeader">
      <int name="status">0</int>
      <int name="QTime">3</int>
    </lst>
    <result name="response" numFound="1" start="0" maxScore="13.722203">
      <doc>
        <float name="score">13.722203</float>
        <date name="date_creation">2011-01-06T23:02:33Z</date>
        <str name="id">969</str>
        <str name="publisher">Widgets, Inc</str>
        <str name="title">Golden Delicious</str>
        <str name="category">Apples</str>
      </doc>
    </result>
    <lst name="highlighting">
      <lst name="969"/>
    </lst>
  </response>

This response will be translated into a hash by httparty. Take a look at your
webserver config/response headers if that does not happen. You need to iterate
over the results yourself in order to do anything useful with the results.
Again, simple!